import streamlit as st
import requests
import os
import logging
from dotenv import load_dotenv
from groq import Groq
from st_audiorec import st_audiorec
import base64

# Logging setup
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Load GROQ API key from .env
load_dotenv()
GROQ_API_KEY = os.getenv("GROQ_API_KEY")
if not GROQ_API_KEY:
    st.error("GROQ_API_KEY is not set. Please check your .env file.")

def transcribe_with_groq(audio_filepath, groq_api_key):
    """
    Transcribe audio using GROQ's speech-to-text API.

    Args:
        audio_filepath (str): Path to the audio file to transcribe.
        groq_api_key (str): GROQ API key.

    Returns:
        str: The transcribed text.
    """
    client = Groq(api_key=groq_api_key)

    if not os.path.exists(audio_filepath):
        st.error(f"Audio file '{audio_filepath}' not found. Please record audio first.")
        return ""

    try:
        with open(audio_filepath, "rb") as audio_file:
            transcription = client.audio.transcriptions.create(
                model="whisper-large-v3-turbo",
                file=audio_file,
                language="en"
            )
        return transcription.text
    except Exception as e:
        st.error(f"Error transcribing audio: {e}")
        return ""

st.set_page_config(layout="wide")
st.title('Multi-Agent Finance Assistant')

ORCHESTRATOR_URL = "http://127.0.0.1:8000"
AUDIO_OUTPUT_DIR = os.path.join(os.path.dirname(os.path.dirname(__file__)), "audio_outputs")
TEMP_AUDIO_FILE = "user_query_recording.wav" # Changed to .wav as st_audiorec outputs WAV

# Create AUDIO_OUTPUT_DIR if it doesn't exist
if not os.path.exists(AUDIO_OUTPUT_DIR):
    os.makedirs(AUDIO_OUTPUT_DIR)

st.subheader("Speak your query:")

w_audio_data = st_audiorec()

recorded_audio_path = os.path.join(AUDIO_OUTPUT_DIR, TEMP_AUDIO_FILE)

if w_audio_data is not None:
    if st.button("Process Recorded Audio"):
        with st.spinner("Saving and Transcribing audio..."):
            try:
                with open(recorded_audio_path, "wb") as f:
                    f.write(w_audio_data) # w_audio_data is bytes
                st.success(f"Audio saved to {recorded_audio_path}")

                if GROQ_API_KEY:
                    transcribed_text = transcribe_with_groq(recorded_audio_path, GROQ_API_KEY)
                    if transcribed_text:
                        st.session_state["transcribed_text"] = transcribed_text
                        st.success("Transcription Complete!")
                        st.write(f"**Your Query:** {transcribed_text}")
                    else:
                        st.error("Failed to transcribe audio.")
                else:
                    st.warning("GROQ API key not set. Cannot transcribe audio.")
            except Exception as e:
                st.error(f"Error processing recorded audio: {e}")

user_query = st.session_state.get("transcribed_text", "")

if st.button('Generate Morning Market Brief'):
    st.info('Generating market brief... Please wait, this may take a moment as agents communicate.')
    
    params = {}
    if user_query:
        params["user_query"] = user_query
        st.info(f"Generating brief for query: '''{user_query}'''")
    else:
        # No recorded or transcribed query. Proceed with a default market brief.
        pass

    try:
        response = requests.post(f"{ORCHESTRATOR_URL}/generate_market_brief", json=params)
        response.raise_for_status()
        brief_data = response.json()

        if brief_data.get("status") in ["success", "fallback_success"]:
            st.success("Market Brief Generated!")
            st.subheader("Text Brief:")
            st.write(brief_data.get("brief_text"))

            if brief_data.get("audio_base64"):
                st.subheader("Listen to the Brief:")
                audio_bytes = base64.b64decode(brief_data["audio_base64"])
                st.audio(audio_bytes, format="audio/wav")
                st.success("Audio brief ready!")
            else:
                st.warning("No audio brief generated by Voice Agent.")
        else:
            st.error(f"Failed to generate brief: {brief_data.get('detail', 'Unknown error')}")

    except requests.exceptions.ConnectionError:
        st.error("Could not connect to the Orchestrator. Please ensure the Orchestrator is running on port 8000.")
    except requests.exceptions.RequestException as e:
        st.error(f"An error occurred while communicating with the Orchestrator: {e}")
    except Exception as e:
        st.error(f"An unexpected error occurred: {e}")

st.markdown("---")
st.markdown("### Agent Status Check (Ensure all agents are running in their terminals):")
st.markdown(f"- **API Agent:** {ORCHESTRATOR_URL.replace(':8000', ':8001')}")
st.markdown(f"- **Scraping Agent:** {ORCHESTRATOR_URL.replace(':8000', ':8002')}")
st.markdown(f"- **Retriever Agent:** {ORCHESTRATOR_URL.replace(':8000', ':8003')}")
st.markdown(f"- **Analysis Agent:** {ORCHESTRATOR_URL.replace(':8000', ':8004')}")
st.markdown(f"- **Language Agent:** {ORCHESTRATOR_URL.replace(':8000', ':8005')}")
st.markdown(f"- **Voice Agent:** {ORCHESTRATOR_URL.replace(':8000', ':8006')}")
st.markdown(f"- **Orchestrator:** {ORCHESTRATOR_URL}") 